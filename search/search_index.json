{"config":{"lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Made For Humans \u00b6 Supersql is a very thin wrapper on top of SQL that enables you write SQL code with python. Take the full power of python to SQL Create advanced queries i.e. Recursive Queries, Joins, Functions, Triggers, DDL etc. Use different SQL dialects (Athena, Postgres, MySQL, MariaDB, Oracle, MSSQL, SQLite etc.) Query Quickstart \u00b6 There are 4 ways to query your data using SuperSQL Identifier Interpolation Manually create a Table schema Automatically reflect tables from the database Use dict and list with variables Identifier Interpolation \u00b6 from os import environ from supersql import Query user = environ . get ( 'DB_USER' ) pwd = environ . get ( 'DB_PWD' ) dialect = environ . get ( 'DB_ENGINE' ) query = Query ( vendor = dialect , user = user , password = pwd ) results = query . SELECT ( \"first_name\" , \"last_name\" , \"email\" ) . FROM ( \"employees\" ) . WHERE ( \"email = 'someone@example.com'\" ) . run () Magic Literals Are Bad It is usually not advisable to repeat string or other constants in multiple places across your codebase. If you notice string or literal values repeating more than once consider turning them into constants. Identifiers ONLY It is advisable to limit use of strings to only identifiers e.g. column names , table names , ... and operators = , <> etc. Manually Create Table Schema \u00b6 from supersql import Table from supersql import ( Date , Integer , String , UUID , ) class Employee ( Table ): identifier = UUID ( version = 4 ) first_name = String ( required = True ) last_name = String ( 25 ) email = String ( 25 , required = True , unique = True ) age = Integer () created_on = Date () emp = Employee () results = query . SELECT ( emp . first_name , emp . last_name , emp . email ) . FROM ( emp ) . WHERE ( emp . email == 'someone@example.com' ) . execute () # `execute` fetches all data into memory Run vs Execute execute() fetches all data into memory. Do not use with unsafe queries to large tables e.g. SELECT * FROM very_large_table . Use run() as it fetches data in chunks and reconnects as necessary to fetch more data. Auto-Reflect Table Schema \u00b6 ... tables = query . database ( \"dbname\" ) . tables () emp = tables . get ( \"employees\" ) results = query . SELECT ( emp . first_name , emp . last_name , emp . email ) . FROM ( emp ) . WHERE ( emp . email == 'someone@example.com' ) . execute () Use Dict & Lists with Variables \u00b6 from supersql import Query query = Query ( ... ) # connection parameters as required def example ( table , * args , ** kwargs ) alt_results = query . SELECT ( * args ) . FROM ( table ) . WHERE ( ** kwargs ) . run () Okay... How about inserting Data? \u00b6 Adding or inserting data with SuperSQL is just as easy as querying data. However it is important for you to understand that SuperSQL is NOT AN ORM , and that means you can't use some magical table.save() method to insert data to the database. That's now how we roll... So how then do you insert data? Let's look at some code. # borrowing Query and Employee code from above ... def insert ( ** kwargs ): result = query . INSERT ( emp ) . VALUES ( ** kwargs ) . execute () def bulk_insert ( * args ): result = query . INSERT ( emp . first_name , emp . last_name , emp . email ) . VALUES ( args ) . execute () def insert_with_into ( * args ): # Use of INTO(table) used here is 100% optional but arguably # adds readability results = Query . INSERT ( emp . first_name , emp . last_name , emp . email ) . INTO ( emp ) . VALUES ( [ \"John\" , \"Doe\" , \"john.doe@example.net\" ] if not args else args ) . execute () query . INSERT () . INTO () . VALUES () . WHERE_NOT_EXISTS ()","title":"Welcome To Supersql"},{"location":"#made-for-humans","text":"Supersql is a very thin wrapper on top of SQL that enables you write SQL code with python. Take the full power of python to SQL Create advanced queries i.e. Recursive Queries, Joins, Functions, Triggers, DDL etc. Use different SQL dialects (Athena, Postgres, MySQL, MariaDB, Oracle, MSSQL, SQLite etc.)","title":"Made For Humans"},{"location":"#query-quickstart","text":"There are 4 ways to query your data using SuperSQL Identifier Interpolation Manually create a Table schema Automatically reflect tables from the database Use dict and list with variables","title":"Query Quickstart"},{"location":"#identifier-interpolation","text":"from os import environ from supersql import Query user = environ . get ( 'DB_USER' ) pwd = environ . get ( 'DB_PWD' ) dialect = environ . get ( 'DB_ENGINE' ) query = Query ( vendor = dialect , user = user , password = pwd ) results = query . SELECT ( \"first_name\" , \"last_name\" , \"email\" ) . FROM ( \"employees\" ) . WHERE ( \"email = 'someone@example.com'\" ) . run () Magic Literals Are Bad It is usually not advisable to repeat string or other constants in multiple places across your codebase. If you notice string or literal values repeating more than once consider turning them into constants. Identifiers ONLY It is advisable to limit use of strings to only identifiers e.g. column names , table names , ... and operators = , <> etc.","title":"Identifier Interpolation"},{"location":"#manually-create-table-schema","text":"from supersql import Table from supersql import ( Date , Integer , String , UUID , ) class Employee ( Table ): identifier = UUID ( version = 4 ) first_name = String ( required = True ) last_name = String ( 25 ) email = String ( 25 , required = True , unique = True ) age = Integer () created_on = Date () emp = Employee () results = query . SELECT ( emp . first_name , emp . last_name , emp . email ) . FROM ( emp ) . WHERE ( emp . email == 'someone@example.com' ) . execute () # `execute` fetches all data into memory Run vs Execute execute() fetches all data into memory. Do not use with unsafe queries to large tables e.g. SELECT * FROM very_large_table . Use run() as it fetches data in chunks and reconnects as necessary to fetch more data.","title":"Manually Create Table Schema"},{"location":"#auto-reflect-table-schema","text":"... tables = query . database ( \"dbname\" ) . tables () emp = tables . get ( \"employees\" ) results = query . SELECT ( emp . first_name , emp . last_name , emp . email ) . FROM ( emp ) . WHERE ( emp . email == 'someone@example.com' ) . execute ()","title":"Auto-Reflect Table Schema"},{"location":"#use-dict-lists-with-variables","text":"from supersql import Query query = Query ( ... ) # connection parameters as required def example ( table , * args , ** kwargs ) alt_results = query . SELECT ( * args ) . FROM ( table ) . WHERE ( ** kwargs ) . run ()","title":"Use Dict &amp; Lists with Variables"},{"location":"#okay-how-about-inserting-data","text":"Adding or inserting data with SuperSQL is just as easy as querying data. However it is important for you to understand that SuperSQL is NOT AN ORM , and that means you can't use some magical table.save() method to insert data to the database. That's now how we roll... So how then do you insert data? Let's look at some code. # borrowing Query and Employee code from above ... def insert ( ** kwargs ): result = query . INSERT ( emp ) . VALUES ( ** kwargs ) . execute () def bulk_insert ( * args ): result = query . INSERT ( emp . first_name , emp . last_name , emp . email ) . VALUES ( args ) . execute () def insert_with_into ( * args ): # Use of INTO(table) used here is 100% optional but arguably # adds readability results = Query . INSERT ( emp . first_name , emp . last_name , emp . email ) . INTO ( emp ) . VALUES ( [ \"John\" , \"Doe\" , \"john.doe@example.net\" ] if not args else args ) . execute () query . INSERT () . INTO () . VALUES () . WHERE_NOT_EXISTS ()","title":"Okay... How about inserting Data?"},{"location":"commit/","text":"","title":"Commit"},{"location":"connecting/","text":"","title":"Connecting"},{"location":"database/","text":"Discovering Database Tables \u00b6 DDL via SuperSQL \u00b6 Supersql is not limited to only querying tables Defining Primary & Primary Keys \u00b6 from supersql import Schema from supersql import ( Date , Integer , String , UUID , ) class Employee_Category ( Schema ): __tablename__ = 'employee_categories' identifier = UUID ( postgres = 'uuid_version_4' ) name = String ( 25 ) class Employee ( Schema ): __pk__ = ( 'email' , 'identifier' ) identifier = UUID ( pg = 'uuid_version1' , mysql = None ) email = String ( required = True , unique = None , length = 25 ) age = Integer () first_name = String ( required = True ) last_name = String ( 25 ) created_on = Date ()","title":"Database Discovery"},{"location":"database/#discovering-database-tables","text":"","title":"Discovering Database Tables"},{"location":"database/#ddl-via-supersql","text":"Supersql is not limited to only querying tables","title":"DDL via SuperSQL"},{"location":"database/#defining-primary-primary-keys","text":"from supersql import Schema from supersql import ( Date , Integer , String , UUID , ) class Employee_Category ( Schema ): __tablename__ = 'employee_categories' identifier = UUID ( postgres = 'uuid_version_4' ) name = String ( 25 ) class Employee ( Schema ): __pk__ = ( 'email' , 'identifier' ) identifier = UUID ( pg = 'uuid_version1' , mysql = None ) email = String ( required = True , unique = None , length = 25 ) age = Integer () first_name = String ( required = True ) last_name = String ( 25 ) created_on = Date ()","title":"Defining Primary &amp; Primary Keys"},{"location":"examples/","text":"","title":"Examples"},{"location":"extensions/","text":"","title":"Plugins &amp; Extensions"},{"location":"filter/","text":"","title":"Filter"},{"location":"joins/","text":"","title":"Joins"},{"location":"query/","text":"What is a Query? \u00b6 At the heart of it SuperSQL can simply be viewed as a query generator and database connection proxy. It provides a highl level Query object and all interactions with databases happen via this object. Available High Level Imports There are only 2 imports you will ever need to make no matter no matter how your query needs are, and this correspond to the only high level imports made available by the library. from supersql import Query from supersdql import Table For now let us focus on the supersql.Query object. Create a SuperSQL Query \u00b6 A query object can be created as an orphan (useful in scenarios where simple SQL syntax generation is desired) or as a connected query (with database connection config). Specifying A Dialect Irrespective of the query type i.e. orphaned or connected you are advised to provide an SQL dialect - i.e. the database you are targeting, as to ensure the SQL generated is valid for the eventual database engine. Orphan Query \u00b6 from supersql import Query query = Query () # no dialect provided query_with_dialect = Query ( dialect = \"postgres\" ) An orphan Query is one with no parent database specified i.e. It is not connected to a database and as such can only be used to generate SQL statements. It is advisable to always provide a dialect when initializing a Query so that the correct syntax can be targeted if you eventually decide to connect the Query to a database server. Supported dialects are: postgres oracle mysql or mariadb oracle athena mssql Connected Query \u00b6 from os import environ from supersql import Query dialect = \"postgres\" user = \"postgres\" pwd = \"strong.password.here\" db = \"northwind\" host = \"localhost\" port = 5432 query = Query ( dialect = dialect , user = user , password = pwd , database = db , host = host ) # or query2 = Query ( dialect , user , pwd , database , host , port ) Unlike orphaned queries, connected queries can be used to retrieve results/data from the database server engine. To create a connected query pass in additional parameters to the Query constructor: dialect : What database dialect are you targeting. str user : The database user to connect as. str password : The database password for the provided user. str host : The IP address or hostname where the database lives with optional port information i.e. localhost or localhost:5432 are both valid values. str port : Optional port information (ignored if port is found in host string). int database : The name of the target database on the host. str Query Command API \u00b6 SuperSQL supports almost all SQL commands and the goal is to support all SQL commands before v2020.1 comes out. SQL commands supported as at v2019.3 includes: SELECT FROM WHERE GROUP_BY ORDER_BY AS IN JOIN HAVING LIMIT FETCH OFFSET BETWEEN FUNCTION WITH WITH_RECURSIVE UPSERT INSERT CREATE (tables, databases, extensions, views, triggers, schemas, functions etc.) DROP UPDATE AND OR CAST UNION UNION_ALL For a full list of supported SQL constructs with code examples take a look at the SuperSQL Command Reference . How Query Commands Work? \u00b6 Every query object you create will have all the SQL commands functions as a python method with CAPITALIZED method names, let us nickname these capitalized methods sqlproxies . Perhaps it is more important to note that sqlproxies are chainable and always return an instance of the same query object with the exception of SELECT and WITH queries. SELECT, WITH, and WITH RECURSIVE returns a new Query instance Whilst sqlproxies return the same query object - SELECT does not . It creates a clone of the original query object so every select or subquery select has its own new slate from which to build and execute queries. This is necessary so you don't have to instantiate new query objects in subqueries. You can take a look at the implementation on github to see how SELECT differs from the other sqlproxies from supersql import Query query = Query ( ... ) # connection params as required emp = query . database ( \"mydbname\" ) . tables () . get ( \"employee\" ) select_all = Query . SELECT () . FROM ( emp ) select_all_str = Query . SELECT ( \"*\" ) . FROM ( \"employee\" ) select_all_schema = Query . SELECT ( emp ) . FROM ( emp ) Executing Queries \u00b6 from supersql import Query from mycodebase.schemas import Employee query = Query ( ... ) emp = Employee () statement = query . SELECT ( emp . first_name , emp . last_name , emp . age , emp . email ) . FROM ( emp ) . WHERE ( emp . email == \"john.doe@example.org\" ) results = statement . execute () Executing queries will return an iterable python object that is an instance of the supersql.core.result.Result python class.","title":"Query Data From Database"},{"location":"query/#what-is-a-query","text":"At the heart of it SuperSQL can simply be viewed as a query generator and database connection proxy. It provides a highl level Query object and all interactions with databases happen via this object. Available High Level Imports There are only 2 imports you will ever need to make no matter no matter how your query needs are, and this correspond to the only high level imports made available by the library. from supersql import Query from supersdql import Table For now let us focus on the supersql.Query object.","title":"What is a Query?"},{"location":"query/#create-a-supersql-query","text":"A query object can be created as an orphan (useful in scenarios where simple SQL syntax generation is desired) or as a connected query (with database connection config). Specifying A Dialect Irrespective of the query type i.e. orphaned or connected you are advised to provide an SQL dialect - i.e. the database you are targeting, as to ensure the SQL generated is valid for the eventual database engine.","title":"Create a SuperSQL Query"},{"location":"query/#orphan-query","text":"from supersql import Query query = Query () # no dialect provided query_with_dialect = Query ( dialect = \"postgres\" ) An orphan Query is one with no parent database specified i.e. It is not connected to a database and as such can only be used to generate SQL statements. It is advisable to always provide a dialect when initializing a Query so that the correct syntax can be targeted if you eventually decide to connect the Query to a database server. Supported dialects are: postgres oracle mysql or mariadb oracle athena mssql","title":"Orphan Query"},{"location":"query/#connected-query","text":"from os import environ from supersql import Query dialect = \"postgres\" user = \"postgres\" pwd = \"strong.password.here\" db = \"northwind\" host = \"localhost\" port = 5432 query = Query ( dialect = dialect , user = user , password = pwd , database = db , host = host ) # or query2 = Query ( dialect , user , pwd , database , host , port ) Unlike orphaned queries, connected queries can be used to retrieve results/data from the database server engine. To create a connected query pass in additional parameters to the Query constructor: dialect : What database dialect are you targeting. str user : The database user to connect as. str password : The database password for the provided user. str host : The IP address or hostname where the database lives with optional port information i.e. localhost or localhost:5432 are both valid values. str port : Optional port information (ignored if port is found in host string). int database : The name of the target database on the host. str","title":"Connected Query"},{"location":"query/#query-command-api","text":"SuperSQL supports almost all SQL commands and the goal is to support all SQL commands before v2020.1 comes out. SQL commands supported as at v2019.3 includes: SELECT FROM WHERE GROUP_BY ORDER_BY AS IN JOIN HAVING LIMIT FETCH OFFSET BETWEEN FUNCTION WITH WITH_RECURSIVE UPSERT INSERT CREATE (tables, databases, extensions, views, triggers, schemas, functions etc.) DROP UPDATE AND OR CAST UNION UNION_ALL For a full list of supported SQL constructs with code examples take a look at the SuperSQL Command Reference .","title":"Query Command API"},{"location":"query/#how-query-commands-work","text":"Every query object you create will have all the SQL commands functions as a python method with CAPITALIZED method names, let us nickname these capitalized methods sqlproxies . Perhaps it is more important to note that sqlproxies are chainable and always return an instance of the same query object with the exception of SELECT and WITH queries. SELECT, WITH, and WITH RECURSIVE returns a new Query instance Whilst sqlproxies return the same query object - SELECT does not . It creates a clone of the original query object so every select or subquery select has its own new slate from which to build and execute queries. This is necessary so you don't have to instantiate new query objects in subqueries. You can take a look at the implementation on github to see how SELECT differs from the other sqlproxies from supersql import Query query = Query ( ... ) # connection params as required emp = query . database ( \"mydbname\" ) . tables () . get ( \"employee\" ) select_all = Query . SELECT () . FROM ( emp ) select_all_str = Query . SELECT ( \"*\" ) . FROM ( \"employee\" ) select_all_schema = Query . SELECT ( emp ) . FROM ( emp )","title":"How Query Commands Work?"},{"location":"query/#executing-queries","text":"from supersql import Query from mycodebase.schemas import Employee query = Query ( ... ) emp = Employee () statement = query . SELECT ( emp . first_name , emp . last_name , emp . age , emp . email ) . FROM ( emp ) . WHERE ( emp . email == \"john.doe@example.org\" ) results = statement . execute () Executing queries will return an iterable python object that is an instance of the supersql.core.result.Result python class.","title":"Executing Queries"},{"location":"results/","text":"SuperSQL strives to make it as simple as possible to work with the data returned to you after execution of your queries. To do this it provides two objects A result object that is an instance of the supersql.core.result.Result class And a Row object that is an instance of the supersql.core.row.Row class Results \u00b6 Results are what is returned after executing a query and are a collection of 1 or more Row objects. For instance given the sql command below that returns the table immediately following it. RAW SQL \u00b6 SELECT * FROM employee ORDER BY first_name DESC LIMIT 2 Python (SuperSQL) \u00b6 query . SELECT () . FROM ( emp ) . ORDER_BY ( - emp . first_name ) . LIMIT ( 2 ) . execute () first_name last_name email age John Doe john.doe@example.org 34 Jane Doe jane.doe@example.org 30 will produce a Results Collection with 2 supersql.core.row.Row objects A row here will be a single customer from the total results set (2 customers) that was returned from the database engine.","title":"View and Use Query Results"},{"location":"results/#results","text":"Results are what is returned after executing a query and are a collection of 1 or more Row objects. For instance given the sql command below that returns the table immediately following it.","title":"Results"},{"location":"results/#raw-sql","text":"SELECT * FROM employee ORDER BY first_name DESC LIMIT 2","title":"RAW SQL"},{"location":"results/#python-supersql","text":"query . SELECT () . FROM ( emp ) . ORDER_BY ( - emp . first_name ) . LIMIT ( 2 ) . execute () first_name last_name email age John Doe john.doe@example.org 34 Jane Doe jane.doe@example.org 30 will produce a Results Collection with 2 supersql.core.row.Row objects A row here will be a single customer from the total results set (2 customers) that was returned from the database engine.","title":"Python (SuperSQL)"},{"location":"select/","text":"","title":"Select"},{"location":"tables/","text":"Remember ( SuperSQL is not an ORM ) - Repeat this to yourself as many times as you need to. Supersql Table objects have 2 primary uses: DDL Template for table create statements. Placeholders for table columns to be used as input to the query object. This means that unlike traditional ORMs you can not do things like table.save() , table.query() or table.id = 1000 . Why then is a table so important? Reduce Bugs and Errors as Tables are SQL aware constant declarations from supersql import Query from supersql import Table from supersql import String , Serial class Account ( Table ): identifier = Serial ( pk = True , required = True ) username = String ( 25 , required = True ) email = String ( 50 , unique = True ) password = String ( 512 , required = True ) age = Integer ( validator = is_underage ) def is_underage ( self , age ): # supersql will call this method before # sending value to database return age < 18 query . CREATE_TABLE ( Account ) # without Table schema you would have to type out # the following explicitly query . CREATE_TABLE ( \"account\" ) . COLUMNS ( \"identifier serial PRIMARY KEY NOT NULL\" , \"username varchar(50) NOT NULL\" , \"email varchar(50)\" , \"password varchar(512)\" ) . CONSTRAINT ( \"ux_email_username UNIQUE(email, username)\" ) Table objects allow you to use pythonic comparisons to generate SQL commands account = Account () query . SELECT () . FROM ( account ) . WHERE ( account . created_at == python_datetime ) Table Supported Datatypes \u00b6 A query object can be created as an orphan (useful in scenarios where simple SQL syntax generation is desired) or as a connected query (with database connection config). Boolean \u00b6 Represents Truthy or Falsy values i.e. True/False, Yes/No, 1/0 etc. Datetime \u00b6 Represents all Date, Time, and Timestamp types with support for Naive or Aware python datetime objects. date datetime2 (mssql) datetime datetimeoffset (mssql) smalldatetime (mssql) time timestamp (postgres, mysql) interval (postgres) year (mysql) Integer \u00b6 Represents all non decimal numbers. integer smallint Money etc. Float \u00b6 Represents all non integer numeric values. String \u00b6 Represents varying/variable character arrays, text and alphanumeric values. char varchar text enum set (mysql) etc. UUID \u00b6 Represents the Universally Unique Identifier type. JSONB \u00b6 Maps to key value collection on databases that support JSON storage. Array \u00b6 Maps to an array of other valid database types on supported vendor engines. Spatial \u00b6 Correlates to positional, geographic data types i.e. point, coordinates etc. Network \u00b6 Mac addresses, INET etc data types. from supersql import Table from supersql import String class Example ( Table ): username = String ()","title":"Create Database Tables in Python"},{"location":"tables/#table-supported-datatypes","text":"A query object can be created as an orphan (useful in scenarios where simple SQL syntax generation is desired) or as a connected query (with database connection config).","title":"Table Supported Datatypes"},{"location":"tables/#boolean","text":"Represents Truthy or Falsy values i.e. True/False, Yes/No, 1/0 etc.","title":"Boolean"},{"location":"tables/#datetime","text":"Represents all Date, Time, and Timestamp types with support for Naive or Aware python datetime objects. date datetime2 (mssql) datetime datetimeoffset (mssql) smalldatetime (mssql) time timestamp (postgres, mysql) interval (postgres) year (mysql)","title":"Datetime"},{"location":"tables/#integer","text":"Represents all non decimal numbers. integer smallint Money etc.","title":"Integer"},{"location":"tables/#float","text":"Represents all non integer numeric values.","title":"Float"},{"location":"tables/#string","text":"Represents varying/variable character arrays, text and alphanumeric values. char varchar text enum set (mysql) etc.","title":"String"},{"location":"tables/#uuid","text":"Represents the Universally Unique Identifier type.","title":"UUID"},{"location":"tables/#jsonb","text":"Maps to key value collection on databases that support JSON storage.","title":"JSONB"},{"location":"tables/#array","text":"Maps to an array of other valid database types on supported vendor engines.","title":"Array"},{"location":"tables/#spatial","text":"Correlates to positional, geographic data types i.e. point, coordinates etc.","title":"Spatial"},{"location":"tables/#network","text":"Mac addresses, INET etc data types. from supersql import Table from supersql import String class Example ( Table ): username = String ()","title":"Network"},{"location":"ddl/create/","text":"","title":"Create"},{"location":"dql/select/","text":"","title":"Select"},{"location":"examples/between/","text":"from supersql import Query from .schemas.rental import rental from .schemas.customer import cust q = Query () # YOU CAN OMIT FROM at the expense of less readability for others) between_select = q . SELECT ( cust ) . WHERE ( cust . store_id > 5 & cust . store_id < 10 ) alt_between_select = q . SELECT ( cust ) . WHERE ( cust . store_id . BETWEEN ( 5 , 10 ) & cust . email in ( 'one@g.com' , 'two@y.com' , 'three@o.com' ) ) alt_select = q . SELECT ( cust . first_name ) . FROM ( cust ) . WHERE ( cust . store_id > 3 & cust . store_id < 5 ) . AND ( cust . email . IN ( 'one@g.com' , 'two@y.com' , 'three@o.com' ) ) . OR ( cust . email in () )","title":"BETWEEN"},{"location":"examples/cast/","text":"from supersql import Query , Date , CAST from datetime import date from supersql.functions import CAST , SUM , COUNT from .tables.actor import Actor from .tables.film import Film , ActorFilm from .tables.customer import cust from .tables.rental import rental query = Query () actor = Actor () actor_film = ActorFilm () f = query . FUNCTION () query_cast = query . SELECT ( actor . actor_id , actor . first_name ) . FROM ( actor ) . WHERE ( f . cast ( actor . last_update ) . AS ( Date ) == '2005-05-27' ) shorthand_cast = query . SELECT ( actor . actor_id , actor . first_name ) . FROM ( actor ) . WHERE ( # shorthand syntax, notice the absence of f.CAST actor . last_update . AS ( Date ) == '2005-05-27' ) function_cast = query . SELECT ( cust . first_name , cust . last_name ) . WHERE ( cust . customer_id in query . SELECT ( cust . customer_id ) . FROM ( rental ) . WHERE ( f . cast ( rental . return_date ) . AS ( date ) == '2005-05-27' ) )","title":"CAST"},{"location":"examples/concat-alias/","text":"from supersql import Query from .schemas.actor import actor from .schemas.film import film q = Query () add_concat_alias = q . SELECT ( actor . first_name + \" \" + actor . last_name ) . AS ( \"alias_name\" ) . FROM ( actor ) alt_concat_alias = q . SELECT ( actor . first_name , \" \" , actor . last_name ) . AS ( \"alias_name\" ) . WHERE ( actor . actor_id in ( 4 , 5 ) ) # This query will also work because you are selecting # from actor i.e. SELECT first_name AS column_alias FROM actor; # The where and from are optional in such a case; alt = q . SELECT ( actor . first_name . AS ( \"column_alias\" ) ) # No support for table aliases as it is unncessary # e.g. SELECT f.name, f.age FROM for_a_very_long_table_name AS f; # but if we wanted to suppor it it might look like unsupported_q = q . SELECT ( \"f.first_name\" , \"f.last_name\" ) . FROM ( actor . AS ( \"f\" ) ) # And for join would have been thus if supported unsupported_q = q . SELECT ( \"f.actor_id\" , \"a.actor_id\" \"f.last_name\" ) . FROM ( film . AS ( \"f\" ) # or all text i.e. 'actor as f' ) . JOIN ( actor . AS ( \"a\" ) # can also use all text, but what's the point then? ) . ON ( film . actor_id == actor . actor_id )","title":"CONCAT Alias"},{"location":"examples/connecting/","text":"from supersql import Query q = Query ( vendor = \"postgres\" , user = \"postgres\" , password = \"postgres\" , server = \"localhost:5432\" , ) # or q = Query ( user = \"postgres\" , password = \"password\" , server = \"postgresql:=localhost:5432/mydatabase\" ) # or q = Query ( \"postgresql:=localhost:5432/mydatabase(username:=password)\" ) # You can also change the gopher delimiter # to whatever you want q = Query ( \"postgresql:::localhost/mydatabase(username:::mypassword)\" , esc = \":::\" ) host = \"postgresql:=localhost:5432/mydatabase\" prompt_for_password = Query ( user = \"postgres\" , prompt_password = True , host = host )","title":"Connection"},{"location":"examples/cursor/","text":"from supersql import Query from examples import config q = Query ( ** config ) select_command = q . SELECT ( * ) . FROM ( \"customers\" ) command = q . DECLARE ( \"my_custom_cursor\" ) . CURSOR () . FOR ( select_command ) # which is same as alternate_command = cursivator ( select_command ) def cursivator ( query , cursor_name = \"my_cursor_name\" ): return q . DECLARE ( cursor_name ) . CURSOR () . FOR ( query ) first_100_results = command . NEXT ( 100 ) # or command.FETCH_NEXT(x) or command.FETCH(x) prior_100 = command . PRIOR ( 100 ) # or command.FETCH_PRIOR(x)","title":"Cursor"},{"location":"examples/delete/","text":"from supersql import Query from src.examples import config from src.examples.tables.actor import actor query = Query ( ** config ) sql = query . DELETE_FROM ( actor ) . WHERE ( actor . first_name == 'John' ) . AND ( actor . last_name == 'Doe' ) results = sql . execute () sql = query . DELETE ( actor ) . WHERE ( actor . id == 1 ) results = sql . execute ()","title":"DELETE"},{"location":"examples/enum/","text":"# Postgres specific from supersql import Query from supersql import Timestamp from supersql.examples import config query = Query ( ** config ) query . CREATE_TYPE ( \"rainbow\" ) . AS_ENUM ({ \"red\" , \"orange\" , \"yellow\" , \"green\" , \"blue\" , \"purple\" })","title":"ENUM"},{"location":"examples/excepts/","text":"from supersql import Query from examples import config q = Query ( ** config ) exc = q . SELECT ( \"*\" ) . FROM ( \"table\" ) . EXCEPT ( q . SELECT () )","title":"Excepts"},{"location":"examples/fetch/","text":"","title":"Fetch"},{"location":"examples/function/","text":"from suerpsql import Query , Schema , String class Department ( Schema ): __tablename__ = 'deaprtments' name = String ( 25 ) query = Query ( vendor = \"postgres\" , host = \"localhost:5432\" , port = 5432 , user = \"postgres\" , password = \"postgres:user:password\" ) expected_sql = \"\"\" CREATE FUNCTION get_department(text) RETURNS departments AS $$ SELECT * FROM departments WHERE name = $1m $$ LANGUAGE SQL; \"\"\" department = Department () tablename = \"tablename\" or department query . FUNCTION ( \"my_function_name\" ) . AS ( query . SELECT () . FROM ( department ) . WHERE ( department . name == \"$1\" ) ) . LANGUAGE ( \"SQL IMMUTABLE STRICT\" ) #This will actually work as it just translates your code to SQL and executes another_expected_sql = \"\"\" CREATE FUNCTION concat_lower_or_upper(a text, b text, uppercase boolean DEFAULT false) AS $$ SELECT CASE WHEN $3 THEN UPPER($1 || ' ' || $2) ELSE LOWER($1 || ' ' || $2) END; $$ LANGUAGE SQL IMMUTABLE STRICT; \"\"\" concat_lower_or_upper = query . FUNCTION ( \"concat_lower_or_upper\" ) . AS ( query . SELECT ( department . name , query . CASE ( query . WHEN ( department . name == 1 ) . THEN ( ) ) ) )","title":"Function"},{"location":"examples/group-by/","text":"from supersql import Query from .schemas.actor import actor from .schemas.payment import paym q = Query () grouped = q . SELECT ( actor ) . FROM ( actor ) . GROUP_BY ( actor . actor_id ) g = q . SELECT ( q . COUNT ( '*' ), paym . customer_id ) . FROM ( paym ) . GROUP_BY ( paym . customer_id ) . ORDER_BY ( paym . customer_id )","title":"GROUP BY"},{"location":"examples/in-select/","text":"from supersql import Query from .schemas.actor import Actor from .schemas.film import Film , ActorFilm query = Query () actor = Actor () actor_film = ActorFilm () pythonic_in = query . SELECT ( actor . actor_id , actor . first_name ) . FROM ( actor ) . WHERE ( # CAVEAT: Might not work across python ports as it unwinds callstack # as a hack to achieve this pythonic workaround # # Kindly use sqllike in below as much as possible actor . actor_id in query . SELECT ( actor_film . actor_id ) . FROM ( actor_film ) ) sqllike_in = query . SELECT ( actor . actor_id , actor . first_name ) . FROM ( actor ) . WHERE ( actor . actor_id . IN ( query . SELECT ( actor_film . actor_id ) . FROM ( actor_film ) ) )","title":"IN Select"},{"location":"examples/insert/","text":"\"\"\" To insert you use the q.INSERT_INTO method or it's shorthand alias q.INSERT \"\"\" from supersql import Schema , Query from supersql import ( String , Integer ) query = Query ( \"postgres:localhost:5432\" ) class Fruit ( Schema ): __tablename__ = 'fruits' name = String ( 25 ) price = Integer () category = String ( 25 ) class Nuts ( Schema ): name = String ( 25 ) price = Integer () description = String ( 250 ) fruits = Fruit () nuts = Nuts () prep = query . INSERT ( fruits . name , fruits . price ) . VALUES ( ( \"Banana\" , 25.04 ,), ( \"Mango\" , 33.00 ), ( \"Apple\" , 22.00 ) ) insert_from_table = query . INSERT ( nuts . name , nuts . price ) . INTO ( nuts ) . VALUES ( query . SELECT ( fruits . name , fruits . price ) . FROM ( fruits ) . WHERE ( fruits . description == \"nuts\" ) ) shorthand_insert = query . INSERT ( nuts . name , nuts . price ) . VALUES ( ( \"Bambara\" , 3.01 ) ) explicit = query . INSERT_INTO ( nuts ) . VALUES ( ... #Your values here, can be one or more lists/tuples )","title":"Insert"},{"location":"examples/join/","text":"\"\"\" A join specifies which table is the Boss LEFT JOIN = Left table is the boss, join right table and if empty show null values RIGHT JOIN = Right table is the boss, join left and if empty show null join/inner join - both tables are the boss \"\"\" from supersql import Query , Schema from supersql import Integer , String , Timestamp from .schemas.customer import cust from .schemas.payment import paym from .schemas.staff import staff class Alpha ( Schema ): __tablename__ = 'alpha' id = Integer () name = String () description = String () last_update = Timestamp () # Let's imagine for some weird reason you want to # inherit the same fields as a previous schema class Beta ( Alpha ): __tablename__ = 'beta' # remove description and add price to thi __exclude__ = 'description' price = Integer () q = Query () a = Alpha () b = Beta () insert_alpha_fruits = q . INSERTINTO ( a . name ) . VALUES ( ( 1 , 'Apple' ), ( 2 , 'Orange' ), ( 3 , 'Pineapple' ), ( 4 , 'Manago' ) ) insert_beta_fruits = q . INSERTINTO ( b . id , b . name ) . VALUES ( # using zip for effect to show power available to supersql from python zip (( 1 , 2 , 3 , 4 ), ( 'Orange' , 'Mango' , 'Apple' , 'Banana' )) ) joined = q . SELECT ( a . id , a . name , b . name . AS ( \"second_fruit\" ), b . id . AS ( \"second_id\" ) ) . FROM ( a ) . JOIN ( b ) . ON ( ) three_way_join = q . SELECT ( cust . customer_id , cust . first_name , cust . last_name , cust . email , paym . amount , paym . payment_date , staff . first_name , staff . last_name ) . FROM ( cust ) . JOIN ( paym ) . ON ( cust . customer_id == paym . customer_id ) . JOIN ( staff ) . ON ( paym . staff_id == staff . staff_id ) . WHERE ( cust . customer_id == 2 ) natural_join = q . SELECT ( cust ) . FROM ( cust ) . NATURAL_JOIN ( paym ) natural_join_using = q . SELECT ( cust ) . FROM ( cust ) . JOIN ( paym ) . USING ( cust . customer_id )","title":"JOIN"},{"location":"examples/null/","text":"from supersql import Query from .schemas.actor import actor q = Query () is_null = q . SELECT ( actor ) . FROM ( actor ) . WHERE ( actor . actor_id is not None ) is_null = q . SELECT ( actor ) . FROM ( actor ) . WHERE ( actor . actor_id is None )","title":"Null"},{"location":"examples/query/","text":"from supersql import Query from supersql import Table from supersql import Connection from supersql import String class Query (): def __init__ ( self , * args , ** kwargs ): pass def AND ( self , * args , ** kwargs ): # do something with parameters passed in return self def FROM ( self , * args ): # do something with from arguments return self def GROUP_BY ( self , * args , ** kwargs ): # do something with parameters passed in return self def ORDER_BY ( self , * args , ** kwargs ): # do something with parameters passed in return self def SELECT ( self , * args , ** kwargs ): # do something with parameters passed in return self def WHERE ( self , * args , ** kwargs ): # do something with parameters passed in return self def run ( self ): \"\"\" Signifies end of query and send/executes/runs query \"\"\" return self . results connection = Connection . get_connection () query = Query ( connection or 'postgres:localhost:5432' , user = 'postgres' , password = 'postgres' ) # Why capitalized? # - Prevent Python Keywords conflict `from`, `and` etc # - SQL Convention query . SELECT ( 'e.identifier' , 'e.first_name' , 'e.last_name' , 'd.identifier' ) . FROM ( 'Employee as e' , 'Department as d' ) . WHERE ( 'd.department' , equals = \"engineering\" ) . AND ( 'e.first_name' , ilike = 'c%' ) . ORDER_BY ( 'e.first_name' , asc = True ) # Now we can both agree that is a lot of magic literals and omitting # the `e` from anywhere it expects to see an e.first_name for more # complex queries will cause an error # # Let's fix that with string formatting help from a custom class # you defined that inherits from Schema class Employee ( Schema ): __pk__ = 'identifier' identifier = UUID ( pg = 'version_1' , mysql = '' ) first_name = String () last_name = String () class Department ( Schema ): __pk__ = ( 'identifier' , 'email' ) # Composite primary key name = String ( length = 25 , required = True , unique = None ) identifier = UUID ( version = 4 ) # Remember this is a schema not a model, you use it as input into # a Query object to get a Results object `array of model representations` # every Result object in Results is your model. # # REMEMBER: This is a schema not a model emp = Employee () dep = Department () # Now let's try again with the schema'd classes results = query . SELECT ( emp . first_name , emp . last_name , emp . identifier , dep . identifier , ) . COUNT ( emp . first_name , alias = 'Tally' ) . FROM ( emp , dep ) . WHERE ( dep . name , equals = 'engineering' ) . AND ( ) . ORDER_BY ( dep . first_name , descending = True ) . GROUP_BY ( ) . run ()","title":"QUERY"},{"location":"examples/results/","text":"\"\"\" .rows() -> iterator .row(0) .to_dataframe() -> Throw error if pandas not found \"\"\" from supersql import Query from supersql import Results , Row from examples import config from examples.tables.actor import Actor actor = \"\"\" actor_id first_name last_name last_update ----------|---------------|---------------|-------------------------| 1 PENELOPE GUINESS 2017-02-15 09:34:33+01 2 NICK WAHLBERG 2017-02-15 09:34:33+01 3 ED CHASE 2017-02-15 09:34:33+01 4 JENNIFER DAVIS 2017-02-15 09:34:33+01 5 JOHNNY LOLLOBRIGIDA 2017-02-15 09:34:33+01 \"\"\" q = Query ( ** config ) actor = Actor () results = q . SELECT () . FROM ( actor ) . execute () # Get a list of all column headers results . columns # -> ['actor_id', 'first_name', 'last_name', 'last_update'] # Cells are the intersection between columns and rows # e.g. 'LOLLOBRIGIDA' is cell(5,3) i.e. 5th Row, 3rd Column # # Every nested list is a row so (5, 3) is 5th list/row, 3rd item/column # [ # [1, 'boy', 'apple'], # [2, 'door', 'gun'], # [3, 'echo', 'mountain'], # [4, 'shark', 'adidas'], # [5, 'air', 'song'] # ] # lollobrigida = results . cell ( 5 , 3 ) print ( lollobrigida ) # -> 'lollobrigida' # To get all values in a col e.g. all first_names ['PENELOPE', 'NICK', 'ED', 'JENNIFER', 'JOHNNY'] # simply call column and pass in the name or number of the column first_names = results . column ( 'first_name' ) first_names_again = results . column ( 2 ) actor_ids = results . column ( 'actor_id' ) # To get a single row i.e. entire data on JOHNNY LOLLOBRIGIDA johnny_lollobrigida = results . row ( 5 ) # Now you can go crazy with Johnny first_name = johnny_lollobrigida . first_name last_name = johnny_lollobrigida . last_name last_updated = johnny_lollobrigida . last_update # Why not enable client side search? Because that should be the JOB of SQL and you # should write a query that returns just what you want # i.e. # Most times you will get a single row or rows already sorted by how you want # so you can get data easily # remember - first position is for column which can be string or number, and second is for row (only numbers) results . cell ( 5 , 3 ) results . column ( 3 , 'first_name' ) results . row ( 0 ) # Want to iterate over all results for data in results . rows (): print ( data . first_name ) print ( data . last_name ) # etc # Special Utility Methods csvfile = results . to_csv ( delimiter = ',' ) # Save to csv file - other options '\\t', dataframe = results . to_dataframe () # to pandas dataframe - raise error if pandas not installed jsondata = results . to_dict () # converts result set to python dict always nested in a list - [{}] or [{}, {}, {}] jsonstring = results . to_json () # string json representation - uses json.dumps(results.to_dict())","title":"Results"},{"location":"examples/select/","text":"from supersql import Query , Schema from supersql import String q = Query ( user = \"postgres\" , password = \"password\" , host = \"localhost/mydb\" ) class Customer ( Schema ): __tablename__ = \"customers\" name = String () # when you use string without arguments it defaults to text data type email = String ( 50 ) # this will be a varchar(50) because a limit is given description = String () store = String () cust = Customer () prep = q . DISTINCT ( cust . name , cust . email ) . FROM ( cust ) . WHERE ( cust . store == '2' ) results = prep . run () distinc_on_prep = q . DISTINCT ( cust . name , cust . email , ON = cust . name ) . FROM ( cust ) . ORDER_BY ( cust . name , # must come first due to postgres rules for distinct on order by usage ) distinct_on_results = distinc_on_prep . run () sqlbutler = q . SELECT ( cust . name , cust . description , cust . email ) . FROM ( cust ) . WHERE ( cust . email == 'one@example.com' ) results = sqlbutler . run () in_select = q . SELECT ( cust . name , cust . email , emp . name ) . FROM ( cust , emp ) . WHERE ( cust . name in ( \"Anna\" , \"Laura\" , \"Everett\" , \"Peter\" ) ) and_select = q . SELECT ( cust . name , cust . email ) . FROM ( cust ) . WHERE ( cust . name == 'mary' & cust . email % '%yahoo.com' ) limit_select = q . SELECT ( cust ) . WHERE ( cust . age > 5 ) . ORDER_BY ( + cust . age , # ASC - cust . name # DESC ) . LIMIT ( 3 ) . OFFSET ( 1 )","title":"Select"},{"location":"examples/unary/","text":"from supersql import Query , Schema , Varchar , String , Integer , Date query = Query ( vendor = 'postgres' , host = 'localhost:5432/mydatabase' , user = 'user' , password = 'password' ) class Customer ( Schema ): __tablename__ = 'customers' first_name = String () last_name = Varchar () email = String ( 25 ) age = Integer () cust = Customer () emp = Employee () waitress = select_between = query . SELECT ( cust . first_name , cust . email ) . FROM ( cust ) . WHERE ( cust . email in ( \"abc\" ) ) . ORDER_BY ( + cust . first_name , - cust . email ) results = waitress . run ()","title":"Unary"},{"location":"examples/union/","text":"from supersql import Query from examples import config from examples.schemas.customer import cust from examples.schemas.staff import staff q = Query ( ** config ) union = q . SELECT ( cust . first_name , cust . last_name , \"customer as type\" ) . FROM ( cust ) . UNION ( q . SELECT ( staff . first_name , staff . last_name , \"customer as type\" ) . FROM ( staff ) ) union_all = q . SELECT ( q . X ( cust . first_name + \" \" + cust . last_name ) . AS ( \"full_name\" ) ) . FROM ( ) . UNION_ALL ( ) prep = q . SELECT () . FROM ( cust ) . WHERE ( cust . email in ( 'hou@one.com' , 'won@thes.co' )) sql_string = prep . sql","title":"UNION"},{"location":"examples/update/","text":"from supersql import Query , Schema from supersql import ( Integer , String , UUID ) query = Query ( vendor = \"postgres\" , host = \"localhost:5432\" , database = \"northwind\" , user = \"postgres\" , password = \"postgres\" ) class Movies ( Schema ): identifier = UUID () name = String () rating = Integer ( datatype = 'integer' ) movies = Movies () update_movies_table = query . UPDATE ( Movies () ) . SET ( ( movies . name , \"value\" ), ( movies . age , \"value\" ) ) . VALUES ( \"The Good, The Bad, The Ugly\" ) class cemp : pass q = query value = \"\" q . UPDATE ( cemp ) . SET ( cemp . name , cemp . age ) . VALUES ( \"Yeti\" , 4 ) q . UPDATE ( cemp ) . SET ( ( cemp . name , value ), ( cemp . age , value ), ( cemp . other_key , value ) ) . WHERE ( cemp . name == \"something\" ) q . UPDATE ( cemp ) . SET ( zip ( cemp . keys (), range ( 5 ))) # method 1: pass in a dictionary of columnname: value - s q . UPDATE ( cemp ) . SET ({ cemp . age : value }) # method 1 alsoa allows you to pass in any object # that implements a `to_dict` method where # this method returns a dictionary of key value pairs cemp = cemp () cemp . first_name = \"some\" cemp . age = 45 q . UPDATE ( cemp ) . SET ( cemp ) class Customer : ... customer = Customer () # method 2: pass in a string q . UPDATE ( \"tablename\" ) . SET ( f \"first_name = ' { customer . first_name } ', age = { customer . age } \" ) # final method q . UPDATE ( cemp ) . SET ( cemp . age << 4 , cemp . first_name << \"\" ) # in the set method inspect each data attribute and raise error if not assigned a value yet q . UPDATE ( cemp ) . SET ( cemp . age = 55 , cemp . first_name = \"John\" , cemp . last_name = \"Doe\" ) q . CREATE_OR_REPLACE_MATERIALZED_VIEW () q . CREATE_MATERIALIZED_VIEW ()","title":"UPDATE"},{"location":"examples/upsert/","text":"","title":"UPSERT"},{"location":"examples/where/","text":"from supersql import Table from supersql import Query from examples import config from examples.tables.customer import cust query = Query ( ** config ) where = query . SELECT ( cust ) . FROM ( cust ) . WHERE ( cust . active == True & cust . address_id == 45 ) alt_where = query . SELECT ( cust ) . FROM ( cust ) . WHERE ( cust . active == True & cust . address_id == 45 & cust . customer_id == 4 | cust . create_date > '2019-09-30' )","title":"WHERE"},{"location":"examples/with-recursive/","text":"from supersql import Query from examples import config from examples.schemas.employee import emp q = Query ( ** config ) EMPS = ( ( 1 , 'Michael North' , NULL ), ( 2 , 'Megan Berry' , 1 ), ( 3 , 'Sarah Berry' , 1 ), ( 4 , 'Zoe Black' , 1 ), ( 5 , 'Tim James' , 1 ), ( 6 , 'Bella Tucker' , 2 ), ( 7 , 'Ryan Metcalfe' , 2 ), ( 8 , 'Max Mills' , 2 ), ( 9 , 'Benjamin Glover' , 2 ), ( 10 , 'Carolyn Henderson' , 3 ), ( 11 , 'Nicola Kelly' , 3 ), ( 12 , 'Alexandra Climo' , 3 ), ( 13 , 'Dominic King' , 3 ), ( 14 , 'Leonard Gray' , 4 ), ( 15 , 'Eric Rampling' , 4 ), ( 16 , 'Piers Paige' , 7 ), ( 17 , 'Ryan Henderson' , 7 ), ( 18 , 'Frank Tucker' , 8 ), ( 19 , 'Nathan Ferguson' , 8 ), ( 20 , 'Kevin Rampling' , 8 ) ) populator = q . INSERT ( emp ) . VALUES ( EMPS ) with_recursive = q . WITH_RECURSIVE ( \"subordinates\" ) . AS ( q . SELECT ( emp . employee_id , emp . manager_id , emp . full_name ) . FROM ( emp ) . WHERE ( emp . manager_id == None ) . UNION ( q . SELECT ( emp . employee_id , emp . manager_id , emp . full_name ) . FROM ( emp ) . JOIN ( q . subordinates ) . ON ( q . subordinates . employee_id == emp . manager_id ) ) )","title":"WITH RECURSIVE"},{"location":"examples/with/","text":"from supersql import Double from supersql import Query , Table query = Query ( ... ) f = query . FUNCTION () DAYS = range ( 1 , 15 ) MONTHS = ( \"November\" , \"December\" , \"January\" ) YEARS = ( 2019 , 2018 , 2017 , 2016 , 2015 ) REGEXPR = \"[a-zA-Z0-9]{{3}}-[a-zA-Z0-9]{{3}}-[a-zA-Z0-9]{{4}}- \\\\ d{{2}}-[a-zA-Z0-9]{{4}}\" table = Table () beetable = Table () sskutable = Table () CASE_REGEXP_LIKE = query . CASE ( f . regexp_like ( table . product_sku , REGEXPR ) ) . WHEN () . THEN ( f . substring ( table . product_sku , 1 , 15 ) ) . ELSE ( f . substring ( table . product_sku , 1 , 13 ) ) . END () # You can leave out END() as it is optional CASE_COUNTRY_IN = query . CASE () . WHEN ( table . country . IN ( 'DACH' ) ) . THEN ( f . upper ( table . country ) ) with_aka_cte = query . WITH ( \"cte_name\" ) . AS ( query . SELECT ( CASE_REGEXP_LIKE , f . replace ( f . trim ( f . lower ( 'retailer_name' ))) . AS ( \"retailer_name\" ), CASE_COUNTRY_IN , f . concat ( table . year , table . month , table . day ) . AS ( \"temp_day\" ), f . substr ( f . min ( table . crawl_date )) . AS ( \"found\" ), f . max ( table . competitor_product_sku ) . AS ( \"identifier\" ), f . round ( f . sum ( table . size_availability_score ), 2 ) . AS ( \"size_availability_score\" ), f . avg ( f . cast ( table . retailer_sale_price . AS ( Double ) )) . AS ( \"current_price\" ), f . min ( table . matching_date ) . AS ( \"matching_date\" ), f . max ( f . cast ( table . retailer_sale_price . AS ( Double ))) . AS ( \"max_current_price\" ), f . max ( f . cast ( table . retailer_price . AS ( Double ))) . AS ( \"max_original_price\" ), f . max ( table . offer_link ) . AS ( \"product_url\" ) ) . FROM ( table ) . LEFT_JOIN ( sskutable ) . ON ( sskutable . simple_sku == table . product_sku ) . WHERE ( table . year . IN ( YEARS ) ) . AND ( table . month . IN ( MONTHS ) ) . AND ( table . day . IN ( DAYS ) ) . GROUP_BY ( 1 , 2 , 3 , 4 ) ) price_cte = query . WITH ( \"price_data\" ) . AS ( query . SELECT ( CASE_REGEXP_LIKE , f . replace ( f . trim ( f . lower ( table . retailer_name ))) . AS ( \"retailer_name\" ), CASE_COUNTRY_IN , f . concat ( table . year , table . month , table . day ) . AS ( \"temp_day\" ), # repetitive code can be put in a python function f . coalesce ( f . max_by ( f . cast ( table . retailer_price . AS ( Double )), table . size_availability_score ), f . min ( f . cast ( table . retailer_sale_price ) . AS ( Double )) ) . AS ( \"retailer_sale_price\" ) ) . FROM ( table ) . LEFT_JOIN ( sskutable ) . ON ( table . product_sku == sskutable . simple_sku ) . WHERE ( table . year . IN ( YEARS ) ) . AND ( table . month . IN ( MONTHS ) ) . AND ( table . days . IN ( DAYS ) ) . GROUP_BY ( 1 , 2 , 3 , 4 ) ) query . SELECT ( with_aka_cte . matched_csku . AS ( \"matched_sku\" ), with_aka_cte . matched_csku . AS ( \" matched_csku\" ), with_aka_cte . retailer_name . AS ( \" retailer_name\" ), with_aka_cte . country_code . AS ( \" country_code\" ), f . max_by ( with_aka_cte . found , with_aka_cte . temp_day ) . AS ( \" found\" ), f . max_by ( with_aka_cte . identifier , with_aka_cte . temp_day ) . AS ( \" identifier\" ), f . max_by ( with_aka_cte . size_availability_score , with_aka_cte . temp_day ) . AS ( \" size_availability_score\" ), f . max_by ( with_aka_cte . current_price , with_aka_cte . temp_day ) . AS ( \" current_price\" ), f . max_by ( with_aka_cte . matching_date , with_aka_cte . temp_day ) . AS ( \" matching_date\" ), f . max_by ( with_aka_cte . max_current_price , with_aka_cte . temp_day ) . AS ( \" max_current_price\" ), f . max_by ( with_aka_cte . max_original_price , with_aka_cte . temp_day ) . AS ( \" max_original_price\" ), f . max_by ( price_cte . retailer_price , with_aka_cte . temp_day ) . AS ( \" retailer_price\" ), f . max_by ( price_cte . retailer_sale_price , with_aka_cte . temp_day ) . AS ( \" retailer_sale_price\" ), f . max_by ( with_aka_cte . product_url , with_aka_cte . temp_day ) . AS ( \"product_url\" ) ) . FROM ( price_cte ) . JOIN ( with_aka_cte ) . ON ( with_aka_cte . matched_csku == price_cte . matched_csku ) . AND ( with_aka_cte . retailer_name == price_cte . retailer_name ) . AND ( with_aka_cte . country_code == price_cte . country_code ) . AND ( with_aka_cte . temp_day == price_cte . temp_day ) . GROUP_BY ( 1 , 2 , 3 )","title":"WITH"},{"location":"examples/without-query/","text":"","title":"Without Query Object"},{"location":"postgres/functions/","text":"","title":"Function"}]}